-------------------------------------------------
-- PACKAGE ERRORES
-------------------------------------------------
CREATE OR REPLACE PACKAGE pkg_errores IS 
    reg_errores registro_error%rowtype;
    v_fecha DATE DEFAULT sysdate;
    v_hora registro_error.hora%TYPE DEFAULT to_char(sysdate,'HH24:MI:SS');
    PROCEDURE sp_errores(correlativo IN registro_error.ID%TYPE, p_codigo_error IN registro_error.codigo_error%TYPE, p_mensaje IN registro_error.mensaje_error%TYPE, p_subprograma registro_error.subprograma%TYPE, p_fecha  IN registro_error.fecha%TYPE, p_hora IN registro_error.hora%TYPE);
END pkg_errores;


----------------------------------------------------
-- PACKAGE BOBY ERRORES
----------------------------------------------------

CREATE OR REPLACE PACKAGE BODY pkg_errores IS 
    PROCEDURE sp_errores(correlativo IN registro_error.ID%TYPE, p_codigo_error IN registro_error.codigo_error%TYPE, p_mensaje IN registro_error.mensaje_error%TYPE, p_subprograma registro_error.subprograma%TYPE, p_fecha  IN registro_error.fecha%TYPE, p_hora IN registro_error.hora%TYPE)
    IS
        v_error VARCHAR2(200);
    BEGIN 
        v_error := 'INSERT INTO registro_error VALUES (:correlativo, :p_codigo_error, :p_mensaje, :p_subprograma, :p_fecha, :p_hora)';
        EXECUTE IMMEDIATE v_error USING correlativo, p_codigo_error, p_mensaje, p_subprograma, p_fecha, p_hora;
        COMMIT;
    END sp_errores;
END pkg_errores;

------------------------------------------------------------------------------
-- TRIGGER LOGIN SESSION 
------------------------------------------------------------------------------

-- Se dispara al ingresar a la BDD

CREATE OR REPLACE TRIGGER trg_login_session
AFTER LOGON ON DATABASE
BEGIN
------------------------------------------------------------------------------
-- FORMATO ZONA HORARIA SANTIAGO CHILE
------------------------------------------------------------------------------
    EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY-MM-DD''';
    -- Indicamos el lenguaje
    EXECUTE IMMEDIATE 'ALTER SESSION SET  NLS_DATE_LANGUAGE=''SPANISH''';
    -- Indicamos la zona horaria America
    EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_TERRITORY = "AMERICA"';
END trg_login_session;




------------------------------------------------------------------------------
-- FORMATO ZONA HORARIA 
------------------------------------------------------------------------------

-- Alteramos el formato fecha de la sesión para que muestre la hora, los minutos y los segundos
ALTER SESSION SET  nls_date_format = 'dd-mm-yyyy hh24:mi:ss';

-- Indicamos el lenguaje
ALTER SESSION SET  nls_date_language='SPANISH';

-- Indicamos la zona horaria America
ALTER SESSION SET nls_territory = "america";

SELECT * FROM nls_session_parameters;

-- Revisamos la Zona Horaria de America/Santiago
SELECT systimestamp AT TIME ZONE CAST( 'America/Santiago' AS VARCHAR2(80)) FROM dual;

SELECT sysdate FROM dual;

-- Verificamos los JOBS creados
SELECT * FROM all_scheduler_jobs;

-- Revisar el log de los JOBS
SELECT * FROM all_scheduler_job_run_details;

COMMIT;

-------------------------------------------------
-- TRIGGER LOGS ASISTENCIA
-------------------------------------------------

CREATE OR REPLACE TRIGGER trg_usuario_logs 
AFTER INSERT OR UPDATE OR DELETE ON usuario
FOR EACH ROW 
DECLARE
    v_sentencia VARCHAR2(200);
    reg_logs registro_logs%rowtype;
BEGIN
        reg_logs.fecha := sysdate;
        reg_logs.hora :=  to_char(sysdate,('HH24:MI:SS'));
    IF inserting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'INSERT';
        reg_logs.mensaje := 'Se insertó un registro en la tabla Usuario con el nombre de  ' || :NEW.nombre_usuario;
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF updating THEN 
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'UPDATE';
        reg_logs.mensaje := 'Se actualizó el usuario ' || :NEW.nombre_usuario || ' de la tabla de Usuario.';
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF deleting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'DELETE';
        reg_logs.mensaje := 'Se eliminó el usuario ' || :OLD.nombre_usuario  || ' de la tabla de Usuario.';
        INSERT INTO registro_logs VALUES reg_logs;
    END IF;
END trg_usuario_logs;

-------------------------------------------------
-- TRIGGER LOGS USUARIO
-------------------------------------------------
CREATE OR REPLACE TRIGGER trg_usuario_logs 
AFTER INSERT OR UPDATE OR DELETE ON usuario
FOR EACH ROW 
DECLARE
    v_sentencia VARCHAR2(200);
    reg_logs registro_logs%rowtype;
BEGIN
        reg_logs.fecha := sysdate;
        reg_logs.hora :=  to_char(sysdate,('HH24:MI:SS'));
    IF inserting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'INSERT';
        reg_logs.mensaje := 'Se insertó un registro en la tabla Usuario con el nombre de  ' || :NEW.nombre_usuario;
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF updating THEN 
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'UPDATE';
        reg_logs.mensaje := 'Se actualizó el usuario ' || :NEW.nombre_usuario || ' de la tabla de Usuario.';
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF deleting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'DELETE';
        reg_logs.mensaje := 'Se eliminó el usuario ' || :OLD.nombre_usuario  || ' de la tabla de Usuario.';
        INSERT INTO registro_logs VALUES reg_logs;
    END IF;
END trg_usuario_logs;

-------------------------------------------------
-- TRIGGER AUDITORIA DDL 
-------------------------------------------------
CREATE OR REPLACE TRIGGER trg_auditoria_ddl 
AFTER DDL ON SCHEMA
DECLARE 
BEGIN 
    INSERT INTO auditoria_ddl VALUES (seq_auditoria_ddl.NEXTVAL, sys_context('USERENV','CURRENT_USER'),ora_dict_obj_type, ora_dict_obj_name, ora_sysevent,sysdate,to_char(sysdate,('HH24:MI:SS')));
END trg_auditoria_ddl;

-------------------------------------------------
-- TRIGGER HORARIO LABORAL 
-------------------------------------------------

CREATE OR REPLACE TRIGGER trg_horario_laboral 
BEFORE INSERT OR UPDATE OR DELETE ON asistencia
DECLARE 
    v_hora NUMBER DEFAULT to_char(sysdate,('HH24'));
    v_dia VARCHAR2(15) DEFAULT TRIM(UPPER(to_char(sysdate, 'DAY','NLS_DATE_LANGUAGE=SPANISH')));
BEGIN
        -- Valida que sólo se pueda hacer operaciones en la semana laboral 
        IF v_dia NOT IN ('SÁBADO','DOMINGO') THEN
            -- Valida que solo se pueda Agregar, Actualizar o Eliminar una Asistencia entre las 8:00 AM y las 18:00 PM
            IF  v_hora BETWEEN 8 AND 18 THEN
                                dbms_output.put_line('REALIZÓ LA OPERACIÓN');
            ELSE
                raise_application_error(-20010,'No se puede realizar la operación fuera del horario laboral.');
            END IF;
        ELSE
            raise_application_error(-20011,'No se puede realizar la operación fuera de la jornada de trabajo.');
        END IF;
END trg_horario_laboral;


-------------------------------------------------
-- FUNCIÓN ALMACENADA TRUNCA TABLAS 
-------------------------------------------------
CREATE OR REPLACE FUNCTION fn_truncar_tabla (p_nombre_tabla IN VARCHAR2) RETURN  NUMBER IS
    v_valida NUMBER DEFAULT 0;
BEGIN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE '||p_nombre_tabla;  
    v_valida:=1;
    COMMIT;
    RETURN v_valida;
EXCEPTION 
    WHEN OTHERS THEN
        pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
        pkg_errores.reg_errores.codigo_error := SQLCODE;
        pkg_errores.reg_errores.mensaje_error := 'La tabla con el nombre '||p_nombre_tabla||' no existe.';
        pkg_errores.reg_errores.subprograma := 'FN_TRUNCAR_TABLA';
        pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
        pkg_errores.reg_errores.hora := pkg_errores.v_hora;
        pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        RETURN v_valida;
END;

-------------------------------------------------
-- PACKAGE ASISTENCIA
-------------------------------------------------

CREATE OR REPLACE PACKAGE  pkg_asistencia IS 
    PROCEDURE sp_insertar_asistencia(estadoid IN asistencia.id_estado%TYPE, valida OUT NUMBER);
    PROCEDURE sp_modificar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, estadoid IN asistencia.id_estado%TYPE, valida OUT NUMBER);
    PROCEDURE sp_eliminar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, valida OUT NUMBER);
    PROCEDURE sp_buscar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, entidad OUT SYS_REFCURSOR ,valida OUT NUMBER);
    PROCEDURE sp_listar_asistencia(lista OUT SYS_REFCURSOR, valida OUT NUMBER);
END pkg_asistencia;

-------------------------------------------------
-- PACKAGE ALUMNO
-------------------------------------------------

CREATE OR REPLACE PACKAGE  pkg_alumno IS 
    PROCEDURE sp_listar_alumno(lista OUT SYS_REFCURSOR, valida OUT NUMBER);
END pkg_alumno;

-------------------------------------------------
-- PACKAGE CODIGO QR
-------------------------------------------------

CREATE OR REPLACE PACKAGE pkg_codigo_qr IS
    -- Procedure que hace un UPDATE en la tabla CLASE
    PROCEDURE sp_generar_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER);
    -- Procedure que verifica si el código QR leído coincide con el código generado por el profesor 
    PROCEDURE sp_escanear_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER);
END pkg_codigo_qr;


-------------------------------------------------
-- PACKAGE ERRORES
-------------------------------------------------
CREATE OR REPLACE PACKAGE pkg_errores IS 
    reg_errores registro_error%rowtype;
    v_fecha DATE DEFAULT sysdate;
    v_hora registro_error.hora%TYPE DEFAULT to_char(sysdate,'HH24:MI:SS');
    PROCEDURE sp_errores(correlativo IN registro_error.ID%TYPE, p_codigo_error IN registro_error.codigo_error%TYPE, p_mensaje IN registro_error.mensaje_error%TYPE, p_subprograma registro_error.subprograma%TYPE, p_fecha  IN registro_error.fecha%TYPE, p_hora IN registro_error.hora%TYPE);
END pkg_errores;

-------------------------------------------------
-- PACKAGE USUARIO
-------------------------------------------------

CREATE OR REPLACE PACKAGE pkg_usuario IS 
    PROCEDURE sp_login(p_usuario IN usuario.nombre_usuario%TYPE, p_contrasenia IN usuario.contrasenia%TYPE, p_tipo_usuario OUT NUMBER, p_nombre OUT persona.nombre%TYPE);
    PROCEDURE sp_cambiar_contrasenia(p_correo IN  persona.email%TYPE, p_nueva_pass IN usuario.contrasenia%TYPE, p_valida OUT NUMBER );
END pkg_usuario;


----------------------------------------------------
-- PACKAGE BOBY ASISTENCIA
----------------------------------------------------

CREATE OR REPLACE PACKAGE BODY pkg_asistencia IS
    PROCEDURE sp_insertar_asistencia(estadoid IN asistencia.id_estado%TYPE, valida OUT NUMBER) IS
    reg_asistencia asistencia%rowtype;
    BEGIN 
        valida := 0;
        reg_asistencia.id_asistencia := seq_asistencia.NEXTVAL;
        reg_asistencia.fecha := sysdate;
        reg_asistencia.hora :=  to_char(sysdate,('HH24:MI:SS'));
        reg_asistencia.id_estado:= estadoid;
        INSERT INTO asistencia VALUES reg_asistencia;
        valida := 1;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_INSERTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_INSERTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
      pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_INSERTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_INSERTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_INSERTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_insertar_asistencia;
    
    PROCEDURE sp_eliminar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, valida OUT NUMBER) IS
    BEGIN
        valida := 0;
        DELETE FROM asistencia WHERE id_asistencia = asistenciaid;
        IF SQL%rowcount > 0 THEN
            valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);

    END sp_eliminar_asistencia;
    
    PROCEDURE sp_modificar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, estadoid IN asistencia.id_estado%TYPE, valida OUT NUMBER)IS
    BEGIN
        valida := 0;
        UPDATE asistencia SET id_estado = estadoid WHERE id_asistencia = asistenciaid;
        IF SQL%rowcount > 0 THEN
            valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_modificar_asistencia;
    
    PROCEDURE sp_buscar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, entidad OUT SYS_REFCURSOR ,valida OUT NUMBER) IS
        v_cantidad NUMBER DEFAULT 0;
    BEGIN 
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM asistencia WHERE id_asistencia = asistenciaid;
        IF v_cantidad > 0 THEN 
            OPEN entidad FOR SELECT A.id_asistencia,asig.descripcion, C.fecha, C.hora_inicio, C.hora_termino,E.descripcion, A.fecha,A.hora,alu.rut,  
                                                        alu.nombre || ' '|| alu.nombre_s ||' '|| alu.nombre_t ||' '|| alu.apellido_p||' '|| alu.apellido_m AS nombre
                                                        FROM asistencia A
                                                        INNER JOIN detalle_asistencia det_a
                                                        ON A.id_asistencia = det_a.id_asistencia
                                                        INNER JOIN clase C
                                                        ON det_a.id_clase = C.id_clase
                                                        INNER JOIN detalle_clase_alu det_c
                                                        ON C.id_clase = det_c.id_clase
                                                        INNER JOIN persona alu
                                                        ON det_c.rut_alumno = alu.rut
                                                        INNER JOIN asignatura asig
                                                        ON C.id_asignatura = asig.id_asignatura
                                                        INNER JOIN estado_asistencia E
                                                        ON A.id_estado = E.id_estado
                                                        WHERE A.id_asistencia = asistenciaid;
            valida := 1;
        END IF;
            EXCEPTION
                WHEN too_many_rows THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN invalid_number THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN no_data_found THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN zero_divide THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN OTHERS THEN 
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := sqlerrm;
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_buscar_asistencia;
    
    PROCEDURE sp_listar_asistencia(lista OUT SYS_REFCURSOR, valida OUT NUMBER) IS
    v_cantidad NUMBER DEFAULT 0;
    BEGIN
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM asistencia;
        IF v_cantidad > 0 THEN 
        OPEN lista FOR SELECT  A.id_asistencia,asig.descripcion, C.fecha, C.hora_inicio, C.hora_termino,E.descripcion, A.fecha,A.hora,pe.rut, 
                                                pe.nombre || ' '|| pe.nombre_s ||' '|| pe.nombre_t ||' '|| pe.apellido_p||' '|| pe.apellido_m AS nombre , cur.descripcion
                                                FROM asistencia A
                                                INNER JOIN detalle_asistencia det_a
                                                ON A.id_asistencia = det_a.id_asistencia
                                                INNER JOIN clase C
                                                ON det_a.id_clase = C.id_clase
                                                INNER JOIN detalle_curso det_c
                                                ON det_c.id_clase = C.id_clase
                                                INNER JOIN curso cur
                                                ON cur.id_curso = det_c.id_curso
                                                INNER JOIN alumno alu
                                                ON cur.id_curso = alu.id_curso
                                                INNER JOIN persona pe
                                                ON alu.rut_alumno = pe.rut
                                                INNER JOIN asignatura asig
                                                ON C.id_asignatura = asig.id_asignatura
                                                INNER JOIN estado_asistencia E
                                                ON A.id_estado = E.id_estado
                                                ORDER BY asig.descripcion ASC, C.fecha ASC;
        valida := 1;
        END IF;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_listar_asistencia;
    
END pkg_asistencia;


----------------------------------------------------
-- PACKAGE BOBY ALUMNO
----------------------------------------------------

CREATE OR REPLACE PACKAGE BODY pkg_alumno IS
    
    PROCEDURE sp_listar_alumno(lista OUT SYS_REFCURSOR, valida OUT NUMBER) IS
    v_cantidad NUMBER DEFAULT 0;
    BEGIN
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM alumno;
        IF v_cantidad > 0 THEN 
        OPEN lista FOR SELECT * FROM persona P
                                INNER JOIN alumno A
                                ON P.rut = A.rut_alumno;
        valida := 1;
        END IF;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_listar_alumno;
    
END pkg_alumno;

-------------------------------------------------
-- PACKAGE BODY USUARIO
-------------------------------------------------
CREATE OR REPLACE PACKAGE BODY pkg_usuario IS
    PROCEDURE sp_login(p_usuario IN usuario.nombre_usuario%TYPE, p_contrasenia IN usuario.contrasenia%TYPE, p_tipo_usuario OUT NUMBER, p_nombre OUT persona.nombre%TYPE) IS
    BEGIN 
        p_tipo_usuario := 0;
        p_nombre := '';
        SELECT P.nombre, u.id_tipo INTO p_nombre, p_tipo_usuario
        FROM usuario u
        INNER JOIN persona P
        ON u.nombre_usuario = P.nombre_usuario
        WHERE u.nombre_usuario = p_usuario AND 
        u.contrasenia = p_contrasenia 
        AND u.id_estado = 1;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_login;
    
    PROCEDURE sp_cambiar_contrasenia(p_correo IN  persona.email%TYPE, p_nueva_pass IN usuario.contrasenia%TYPE, p_valida OUT NUMBER ) IS
        v_registro persona.rut%TYPE;
    BEGIN 
        p_valida := 0;
        SELECT nombre_usuario INTO v_registro
        FROM persona WHERE email = p_correo;
        UPDATE usuario SET contrasenia = p_nueva_pass WHERE nombre_usuario = v_registro;
        IF SQL%rowcount > 0 THEN
            p_valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_cambiar_contrasenia;
END pkg_usuario;

-------------------------------------------------
-- PACKAGE BODY CODIGO QR
-------------------------------------------------

CREATE OR REPLACE PACKAGE BODY pkg_codigo_qr IS
    PROCEDURE sp_generar_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER) IS
    BEGIN 
        p_valida := 0;
        UPDATE clase SET codigo_qr = p_qr WHERE id_clase = claseid;
        IF SQL%rowcount > 0 THEN
            p_valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);

    END sp_generar_codigo;
    
    PROCEDURE sp_escanear_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER) IS
        v_codigo clase.codigo_qr%TYPE;
    BEGIN 
            p_valida := 0;
            SELECT codigo_qr INTO v_codigo
            FROM clase WHERE id_clase = claseid;
        IF v_codigo = p_qr THEN 
            p_valida := 1;
        END IF;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);

    END sp_escanear_codigo;
    
END pkg_codigo_qr;


------------------------------------------------------------------

-- CREAR JOB
------------------------------------------------------------------

BEGIN
    dbms_scheduler.create_job (
       job_name          =>  'Actualizar_fotos_clientes', -- Nombre del JOB 
       job_type            =>  'STORED_PROCEDURE', --  Que ejecuará en este caso un SP
       job_action          =>  'SP_FOTO_CLIENTE', -- Nombre del SP
       start_date          =>  '27-JUL-2021 11:11:00 PM', -- Fecha de Inicio de la ejecución 
       repeat_interval  =>  'FREQ=MONTHLY', -- Frecuencia de ejecución 
       enabled             =>  TRUE); -- Dejamos el JOB activo
END;

------------------------------------------------------------------

-- Borrar un JOB 
------------------------------------------------------------------

BEGIN
  dbms_scheduler.drop_job(job_name => 'Actualizar_fotos_clientes'); 
END;



--- EJECUTAR JOB
EXEC dbms_scheduler.run_job('LIMPIAR_LOGS_LOGIN');



-------------------------------------
-- TEST 
-------------------------------------

SET SERVEROUTPUT ON;
---- Probar LISTAR Y BUSCAR
VAR cursor_x refcursor
VAR v_valida NUMBER
EXEC pkg_asistencia.sp_buscar_asistencia(42,:cursor_x, :v_valida);
PRINT cursor_x;
PRINT v_valida;

DECLARE
    v_tipo NUMBER;
    v_nombre VARCHAR2(200);
BEGIN 
    pkg_usuario.sp_cambiar_contrasenia('jorgealequinn@gmail.com','admin123',v_tipo);
    dbms_output.put_line('Valida es ' || v_tipo );
END;



-- PROCEDURE GENERAR QR, QE ACTUALICE LA TABLA CLASE
-- PROCEDURE LEER QR QUE BUSQUE EL CÓDIGO QR GENERADO e INSERTE LA ASISTENCIA AL LEERLO

-- DETALLE ASISTENCIA Y ASISTENCIA PARA PODER REGISTRAR UNA ASISTENCIA Y ASOCIARLA A UN ALUMNO



COMMIT;