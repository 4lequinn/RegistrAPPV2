-------------------------------------------------
-- PACKAGE ERRORES
-------------------------------------------------
CREATE OR REPLACE PACKAGE pkg_errores IS 
    reg_errores registro_error%rowtype;
    v_fecha DATE DEFAULT sysdate;
    v_hora registro_error.hora%TYPE DEFAULT to_char(sysdate,'HH24:MI:SS');
    PROCEDURE sp_errores(correlativo IN registro_error.ID%TYPE, p_codigo_error IN registro_error.codigo_error%TYPE, p_mensaje IN registro_error.mensaje_error%TYPE, p_subprograma registro_error.subprograma%TYPE, p_fecha  IN registro_error.fecha%TYPE, p_hora IN registro_error.hora%TYPE);
END pkg_errores;


----------------------------------------------------
-- PACKAGE BOBY ERRORES
----------------------------------------------------
CREATE OR REPLACE PACKAGE BODY pkg_errores IS 
    PROCEDURE sp_errores(correlativo IN registro_error.ID%TYPE, p_codigo_error IN registro_error.codigo_error%TYPE, p_mensaje IN registro_error.mensaje_error%TYPE, p_subprograma registro_error.subprograma%TYPE, p_fecha  IN registro_error.fecha%TYPE, p_hora IN registro_error.hora%TYPE)
    IS
        v_error VARCHAR2(200);
    BEGIN 
        v_error := 'INSERT INTO registro_error VALUES (:correlativo, :p_codigo_error, :p_mensaje, :p_subprograma, :p_fecha, :p_hora)';
        EXECUTE IMMEDIATE v_error USING correlativo, p_codigo_error, p_mensaje, p_subprograma, p_fecha, p_hora;
        COMMIT;
    END sp_errores;
END pkg_errores;

------------------------------------------------------------------------------
-- TRIGGER LOGIN SESSION 
------------------------------------------------------------------------------

-- Se dispara al ingresar a la BDD

CREATE OR REPLACE TRIGGER trg_login_session
AFTER LOGON ON DATABASE
BEGIN
------------------------------------------------------------------------------
-- FORMATO ZONA HORARIA SANTIAGO CHILE
------------------------------------------------------------------------------
    EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''DD-MM-YYYY''';
    -- Indicamos el lenguaje
    EXECUTE IMMEDIATE 'ALTER SESSION SET  NLS_DATE_LANGUAGE=''SPANISH''';
    -- Indicamos la zona horaria America
    EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_TERRITORY = "CHILE"';
END trg_login_session;




------------------------------------------------------------------------------
-- FORMATO ZONA HORARIA 
------------------------------------------------------------------------------

-- Alteramos el formato fecha de la sesión para que muestre la hora, los minutos y los segundos
ALTER SESSION SET  nls_date_format = 'dd-mm-yyyy hh24:mi:ss';

-- Indicamos el lenguaje
ALTER SESSION SET  nls_date_language='SPANISH';

-- Indicamos la zona horaria America
ALTER SESSION SET nls_territory = "chile";

SELECT * FROM nls_session_parameters;

-- Revisamos la Zona Horaria de America/Santiago
SELECT systimestamp AT TIME ZONE CAST( 'America/Santiago' AS VARCHAR2(80)) FROM dual;

SELECT sysdate FROM dual;

-------------------------------------------------
-- TRIGGER LOGS ASISTENCIA
-------------------------------------------------

CREATE OR REPLACE TRIGGER trg_asistencia_logs 
AFTER INSERT OR UPDATE OR DELETE ON asistencia
FOR EACH ROW 
DECLARE
    reg_logs registro_logs%rowtype;
BEGIN
        reg_logs.fecha := sysdate;
        reg_logs.hora :=  to_char(sysdate,('HH24:MI:SS'));
    IF inserting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'INSERT';
        reg_logs.mensaje := 'Se insertó un registro en la tabla ASISTENCIA con el ID  ' || :NEW.id_asistencia;
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF updating THEN 
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'UPDATE';
        reg_logs.mensaje := 'Se actualizó la asistencia con el ID ' || :NEW.id_asistencia || ' de la tabla de ASISTENCIA..';
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF deleting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'DELETE';
        reg_logs.mensaje := 'Se eliminó la asistencia con el ID ' || :OLD.id_asistencia  || ' de la tabla de ASISTENCIA.';
        INSERT INTO registro_logs VALUES reg_logs;
    END IF;
END trg_asistencia_logs;

-------------------------------------------------
-- TRIGGER LOGS USUARIO
-------------------------------------------------
CREATE OR REPLACE TRIGGER trg_usuario_logs 
AFTER INSERT OR UPDATE OR DELETE ON usuario
FOR EACH ROW 
DECLARE
    v_sentencia VARCHAR2(200);
    reg_logs registro_logs%rowtype;
BEGIN
        reg_logs.fecha := sysdate;
        reg_logs.hora :=  to_char(sysdate,('HH24:MI:SS'));
    IF inserting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'INSERT';
        reg_logs.mensaje := 'Se insertó un registro en la tabla Usuario con el nombre de  ' || :NEW.nombre_usuario;
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF updating THEN 
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'UPDATE';
        reg_logs.mensaje := 'Se actualizó el usuario ' || :NEW.nombre_usuario || ' de la tabla de Usuario.';
        INSERT INTO registro_logs VALUES reg_logs;
    ELSIF deleting THEN
        reg_logs.correlativo := seq_logs.NEXTVAL;
        reg_logs.operacion := 'DELETE';
        reg_logs.mensaje := 'Se eliminó el usuario ' || :OLD.nombre_usuario  || ' de la tabla de Usuario.';
        INSERT INTO registro_logs VALUES reg_logs;
    END IF;
END trg_usuario_logs;

-------------------------------------------------
-- TRIGGER AUDITORIA DDL 
-------------------------------------------------
CREATE OR REPLACE TRIGGER trg_auditoria_ddl 
AFTER DDL ON SCHEMA
DECLARE 
BEGIN 
    INSERT INTO auditoria_ddl VALUES (seq_auditoria_ddl.NEXTVAL, sys_context('USERENV','CURRENT_USER'),ora_dict_obj_type, ora_dict_obj_name, ora_sysevent,sysdate,to_char(sysdate,('HH24:MI:SS')));
END trg_auditoria_ddl;

-------------------------------------------------
-- TRIGGER HORARIO LABORAL 
-------------------------------------------------

CREATE OR REPLACE TRIGGER trg_horario_laboral 
BEFORE INSERT OR UPDATE OR DELETE ON asistencia
DECLARE 
    v_hora NUMBER DEFAULT to_char(sysdate,('HH24'));
    v_dia VARCHAR2(15) DEFAULT TRIM(UPPER(to_char(sysdate, 'DAY','NLS_DATE_LANGUAGE=SPANISH')));
BEGIN
        -- Valida que sólo se pueda hacer operaciones en la semana laboral 
        IF v_dia NOT IN ('SÁBADO','DOMINGO') THEN
            -- Valida que solo se pueda Agregar, Actualizar o Eliminar una Asistencia entre las 8:00 AM y las 18:00 PM
            IF  v_hora BETWEEN 8 AND 18 THEN
                                dbms_output.put_line('REALIZÓ LA OPERACIÓN');
            ELSE
                raise_application_error(-20010,'No se puede realizar la operación fuera del horario laboral.');
            END IF;
        ELSE
            raise_application_error(-20011,'No se puede realizar la operación fuera de la jornada de trabajo.');
        END IF;
END trg_horario_laboral;

-------------------------------------------------
-- FUNCIÓN ALMACENADA VALIDA ASISTENCIA
-------------------------------------------------
CREATE OR REPLACE FUNCTION fn_validar_asistencia(p_claseid IN NUMBER, p_rutalumno alumno.rut_alumno%TYPE) RETURN NUMBER IS
    v_id NUMBER;
BEGIN
        SELECT id_clase INTO v_id 
        FROM detalle_asistencia 
        WHERE rut_alumno = p_rutalumno AND id_clase = p_claseid;
    RETURN 1;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 0;
END fn_validar_asistencia ;

-------------------------------------------------
-- TRIGGER VALIDA ASISTENCIA
-------------------------------------------------
CREATE OR REPLACE TRIGGER trg_validar_asistencia 
BEFORE INSERT ON detalle_asistencia
FOR EACH ROW 
DECLARE 
    v_valida NUMBER DEFAULT 0;
BEGIN
    -- OJO CREAR UN PROCEDURE QUE BUSQUE Y QUE TENGA UN BLOQUE EXCEPTION SI NO ENCUENTRA
    -- PROBAR
    v_valida := fn_validar_asistencia(:NEW.id_clase,  :NEW.rut_alumno );
    IF v_valida = 1 THEN
            raise_application_error(-20012,'Se intentó registrar la asistencia del alumno con el rut '||:NEW.rut_alumno||' en la clase con el identificador ' || :NEW.id_clase||' repetidas veces.' );
    END IF; 
END trg_validar_asistencia;

-------------------------------------------------
-- FUNCIÓN ALMACENADA TRUNCA TABLAS 
-------------------------------------------------
CREATE OR REPLACE FUNCTION fn_truncar_tabla (p_nombre_tabla IN VARCHAR2) RETURN  NUMBER IS
    v_valida NUMBER DEFAULT 0;
BEGIN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE '||p_nombre_tabla;  
    v_valida:=1;
    COMMIT;
    RETURN v_valida;
EXCEPTION 
    WHEN OTHERS THEN
        pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
        pkg_errores.reg_errores.codigo_error := SQLCODE;
        pkg_errores.reg_errores.mensaje_error := 'La tabla con el nombre '||p_nombre_tabla||' no existe.';
        pkg_errores.reg_errores.subprograma := 'FN_TRUNCAR_TABLA';
        pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
        pkg_errores.reg_errores.hora := pkg_errores.v_hora;
        pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        RETURN v_valida;
END;


-------------------------------------------------
-- FUNCIÓN ALMACENADA 
-- OBTENER NOMBRE PROFESOR
-------------------------------------------------
CREATE OR REPLACE FUNCTION fn_obtener_nombre_profesor(p_rut IN profesor.rut_profesor%TYPE) RETURN VARCHAR2 IS
    v_nombre VARCHAR2(150);
BEGIN
    SELECT pe.nombre || ' '|| pe.nombre_s ||' '|| pe.nombre_t ||' '|| pe.apellido_p||' '|| pe.apellido_m INTO v_nombre
    FROM persona pe
    WHERE rut = p_rut;
    RETURN v_nombre;
EXCEPTION
    WHEN OTHERS THEN
        pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
        pkg_errores.reg_errores.codigo_error := SQLCODE;
        pkg_errores.reg_errores.mensaje_error := sqlerrm;
        pkg_errores.reg_errores.subprograma := 'FN_OBTENER_NOMBRE_PROFESOR';
        pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
        pkg_errores.reg_errores.hora := pkg_errores.v_hora;
        pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);        
        RETURN 'N/A';
END fn_obtener_nombre_profesor;

-------------------------------------------------
-- FUNCIÓN ALMACENADA 
-- OBTENER CANTIDAD DE ASISTENCIAS
-------------------------------------------------
CREATE OR REPLACE FUNCTION fn_obtener_cantidad_asistencia(p_rut_alumno IN alumno.rut_alumno%type, p_asignaturaid in asignatura.id_asignatura%type) RETURN NUMBER IS
    v_cantidad number DEFAULT 0;
BEGIN
    SELECT  COUNT(a.id_asistencia) INTO v_cantidad
        FROM asistencia A
        INNER JOIN detalle_asistencia det_a
        ON A.id_asistencia = det_a.id_asistencia
        INNER JOIN estado_asistencia E
        ON A.id_estado = E.id_estado
        INNER JOIN clase C
        ON det_a.id_clase = C.id_clase
        INNER JOIN persona pe
        ON det_a.rut_alumno = pe.rut
        INNER JOIN alumno alu
        ON det_a.rut_alumno = alu.rut_alumno
        INNER JOIN curso cur
        ON cur.id_curso = alu.id_curso
        INNER JOIN asignatura asig
        ON C.id_asignatura = asig.id_asignatura
        where e.id_Estado IN (1,3) and alu.rut_alumno= p_rut_alumno and asig.id_asignatura = p_asignaturaid;
        return v_cantidad;
EXCEPTION
    WHEN OTHERS THEN 
        RETURN v_cantidad;
END;

-------------------------------------------------
-- PROCEDIMIENTO ALMACENDO
-- RESUMEN ASISTENCIA 
-------------------------------------------------
CREATE OR REPLACE PROCEDURE sp_resumen_asistencia IS
    v_valida NUMBER(1);
    reg_resumen resumen_asistencia%rowtype;
    v_asignaturaid asignatura.id_asignatura%type;
    CURSOR cur_resumen IS 
                SELECT  alu.rut_alumno, c.rut_profesor, asig.id_asignatura, asig.descripcion, pe.nombre || ' '|| pe.nombre_s ||' '|| pe.nombre_t ||' '|| pe.apellido_p||' '|| pe.apellido_m AS "nombre_completo" 
                                                    FROM asistencia A
                                                    INNER JOIN detalle_asistencia det_a
                                                    ON A.id_asistencia = det_a.id_asistencia
                                                    INNER JOIN estado_asistencia E
                                                    ON A.id_estado = E.id_estado
                                                    INNER JOIN clase C
                                                    ON det_a.id_clase = C.id_clase
                                                    INNER JOIN persona pe
                                                    ON det_a.rut_alumno = pe.rut
                                                    INNER JOIN alumno alu
                                                    ON det_a.rut_alumno = alu.rut_alumno
                                                    INNER JOIN curso cur
                                                    ON cur.id_curso = alu.id_curso
                                                    INNER JOIN asignatura asig
                                                    ON C.id_asignatura = asig.id_asignatura;
BEGIN
    -- TRUNCAR LA TABLA DE RESUMEN ANTES DE INSERTAR DATOS
    v_valida := fn_truncar_tabla('RESUMEN_ASISTENCIA');
    IF v_valida = 1 THEN 
        OPEN cur_resumen;
        LOOP 
            BEGIN
                FETCH cur_resumen INTO reg_resumen.rut_alumno, reg_resumen.rut_profesor, v_asignaturaid, reg_resumen.asignatura, reg_resumen.alumno;
                    reg_resumen.id_resumen := seq_resumen_asistencia.NEXTVAL;
                    reg_resumen.profesor := fn_obtener_nombre_profesor(reg_resumen.rut_profesor);
                    reg_resumen.cant_asistencia := fn_obtener_cantidad_asistencia(reg_resumen.rut_alumno,v_asignaturaid);
                EXIT WHEN cur_resumen%notfound;
                    
                INSERT INTO resumen_asistencia VALUES reg_resumen;
            EXCEPTION
                WHEN OTHERS THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := sqlerrm;
                    pkg_errores.reg_errores.subprograma := 'SP_RESUMEN_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);        
            END;
        END LOOP;
        CLOSE cur_resumen;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
        pkg_errores.reg_errores.codigo_error := SQLCODE;
        pkg_errores.reg_errores.mensaje_error := sqlerrm;
        pkg_errores.reg_errores.subprograma := 'SP_RESUMEN_ASISTENCIA';
        pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
        pkg_errores.reg_errores.hora := pkg_errores.v_hora;
        pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);        
END sp_resumen_asistencia;

-------------------------------------------------
-- PACKAGE ASISTENCIA
-------------------------------------------------

CREATE OR REPLACE PACKAGE  pkg_asistencia IS 
    PROCEDURE sp_insertar_asistencia(estadoid IN asistencia.id_estado%TYPE, claseid IN detalle_asistencia.id_clase%TYPE, rut_alumno IN detalle_asistencia.rut_alumno%TYPE,valida OUT NUMBER) ;
    PROCEDURE sp_modificar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, estadoid IN asistencia.id_estado%TYPE, valida OUT NUMBER);
    PROCEDURE sp_eliminar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, valida OUT NUMBER);
    PROCEDURE sp_buscar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, entidad OUT SYS_REFCURSOR ,valida OUT NUMBER);
    PROCEDURE sp_listar_asistencia(lista OUT SYS_REFCURSOR, valida OUT NUMBER);
    -- Crear SP que liste a todos los alumnos de una clase y curso en especifico
    PROCEDURE SP_LISTAR_ASISTENCIA_CLASE(p_claseid clase.id_clase%type, p_cursoid clase.id_curso%type, lista OUT SYS_REFCURSOR, valida OUT NUMBER);
   -- CREAR SP GUARDAR ASISTENCIA QUE DEJA AUSENTE A LOS QUE NO ESCANEAN EL CÓDIGO QR
   PROCEDURE SP_GUARDAR_ASISTENCIA (p_claseid clase.id_clase%type, p_cursoid clase.id_curso%type, p_valida OUT NUMBER);
    -- Crear SP que busque el estado de asistencia de un alumno por su rut y clase
    PROCEDURE sp_buscar_asistencia2(p_rutalumno IN alumno.rut_alumno%type, p_claseid IN CLASE.id_clase%type ,valida OUT NUMBER);
    -- Crear un SP que liste la cantidad de asistencias por asignatura (de un alumno en especifico) 
    PROCEDURE SP_LISTAR_ASISTENCIA_ASIGNATURA(p_rutalumno IN alumno.rut_alumno%type, lista OUT SYS_REFCURSOR);
END pkg_asistencia;

-------------------------------------------------
-- PACKAGE ALUMNO
-------------------------------------------------

CREATE OR REPLACE PACKAGE  pkg_alumno IS 
    PROCEDURE sp_listar_alumno(lista OUT SYS_REFCURSOR, valida OUT NUMBER);
END pkg_alumno;

-------------------------------------------------
-- PACKAGE CODIGO QR
-------------------------------------------------

CREATE OR REPLACE PACKAGE pkg_codigo_qr IS
    -- Procedure que hace un UPDATE en la tabla CLASE
    PROCEDURE sp_generar_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER);
    -- Procedure que verifica si el código QR leído coincide con el código generado por el profesor 
    PROCEDURE sp_escanear_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER);
END pkg_codigo_qr;


-------------------------------------------------
-- PACKAGE USUARIO
-------------------------------------------------

CREATE OR REPLACE PACKAGE pkg_usuario IS 
    PROCEDURE sp_login(p_usuario IN usuario.nombre_usuario%TYPE, p_contrasenia IN usuario.contrasenia%TYPE, p_tipo_usuario OUT NUMBER, p_nombre OUT persona.nombre%TYPE);
    PROCEDURE sp_cambiar_contrasenia(p_correo IN  persona.email%TYPE, p_nueva_pass IN usuario.contrasenia%TYPE, p_valida OUT NUMBER );
END pkg_usuario;


----------------------------------------------------
-- PACKAGE BOBY ASISTENCIA
----------------------------------------------------

CREATE OR REPLACE PACKAGE BODY pkg_asistencia IS
    PROCEDURE sp_insertar_asistencia(estadoid IN asistencia.id_estado%TYPE, claseid IN detalle_asistencia.id_clase%TYPE, rut_alumno IN detalle_asistencia.rut_alumno%TYPE,valida OUT NUMBER) IS
    reg_asistencia asistencia%rowtype;
    reg_detalle_asistencia detalle_asistencia%rowtype;
    BEGIN 
        valida := 0;
        reg_asistencia.id_asistencia := seq_asistencia.NEXTVAL;
        reg_asistencia.fecha := sysdate;
        reg_asistencia.hora :=  to_char(sysdate,('HH24:MI:SS'));--- TILT
        reg_asistencia.id_estado:= estadoid;

        reg_detalle_asistencia.id_detalle_asist := seq_detalle_asistencia.NEXTVAL;
        reg_detalle_asistencia.id_asistencia := reg_asistencia.id_asistencia;
        reg_detalle_asistencia.id_clase := claseid;
        reg_detalle_asistencia.rut_alumno := rut_alumno;

        INSERT INTO asistencia VALUES reg_asistencia;
        COMMIT;
        INSERT INTO detalle_asistencia VALUES reg_detalle_asistencia;
        valida := 1;
        COMMIT;
    EXCEPTION
         WHEN OTHERS THEN 
            -- Validación
            DELETE FROM asistencia WHERE id_asistencia = reg_asistencia.id_asistencia;
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_INSERTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_insertar_asistencia;
    
    PROCEDURE sp_eliminar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, valida OUT NUMBER) IS
    BEGIN
        valida := 0;
        DELETE FROM asistencia WHERE id_asistencia = asistenciaid;
        IF SQL%rowcount > 0 THEN
            valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_ELIMINAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);

    END sp_eliminar_asistencia;
    
    PROCEDURE sp_modificar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, estadoid IN asistencia.id_estado%TYPE, valida OUT NUMBER)IS
    BEGIN
        valida := 0;
        UPDATE asistencia SET id_estado = estadoid WHERE id_asistencia = asistenciaid;
        IF SQL%rowcount > 0 THEN
            valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_MODIFICAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_modificar_asistencia;
    
    PROCEDURE sp_buscar_asistencia(asistenciaid IN asistencia.id_asistencia%TYPE, entidad OUT SYS_REFCURSOR ,valida OUT NUMBER) IS
        v_cantidad NUMBER DEFAULT 0;
    BEGIN 
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM asistencia WHERE id_asistencia = asistenciaid;
        IF v_cantidad > 0 THEN 
            OPEN entidad FOR 
                    SELECT  A.id_asistencia,asig.descripcion, C.fecha, C.hora_inicio, C.hora_termino,E.descripcion, A.fecha,A.hora,pe.rut, 
                                                pe.nombre || ' '|| pe.nombre_s ||' '|| pe.nombre_t ||' '|| pe.apellido_p||' '|| pe.apellido_m AS "nombre_completo" , cur.descripcion
                                                FROM asistencia A
                                                INNER JOIN detalle_asistencia det_a
                                                ON A.id_asistencia = det_a.id_asistencia
                                                INNER JOIN estado_asistencia E
                                                ON A.id_estado = E.id_estado
                                                INNER JOIN clase C
                                                ON det_a.id_clase = C.id_clase
                                                INNER JOIN persona pe
                                                ON det_a.rut_alumno = pe.rut
                                                INNER JOIN alumno alu
                                                ON det_a.rut_alumno = alu.rut_alumno
                                                INNER JOIN curso cur
                                                ON cur.id_curso = alu.id_curso
                                                INNER JOIN asignatura asig
                                                ON C.id_asignatura = asig.id_asignatura
                                                WHERE A.id_asistencia = asistenciaid
                                                ORDER BY asig.descripcion ASC, C.fecha ASC, "nombre_completo" ASC;
            valida := 1;
        END IF;
            EXCEPTION
                WHEN too_many_rows THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN invalid_number THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN no_data_found THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN zero_divide THEN
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                WHEN OTHERS THEN 
                    pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                    pkg_errores.reg_errores.codigo_error := SQLCODE;
                    pkg_errores.reg_errores.mensaje_error := sqlerrm;
                    pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_BUSCAR_ASISTENCIA';
                    pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                    pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                    pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_buscar_asistencia;
    
    PROCEDURE sp_listar_asistencia(lista OUT SYS_REFCURSOR, valida OUT NUMBER) IS
    v_cantidad NUMBER DEFAULT 0;
    BEGIN
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM asistencia;
        IF v_cantidad > 0 THEN 
            OPEN lista FOR 
            SELECT  A.id_asistencia,asig.descripcion, C.fecha, C.hora_inicio, C.hora_termino,E.descripcion, A.fecha,A.hora,pe.rut, 
                                                    pe.nombre || ' '|| pe.nombre_s ||' '|| pe.nombre_t ||' '|| pe.apellido_p||' '|| pe.apellido_m AS "nombre_completo" , cur.descripcion
                                                    FROM asistencia A
                                                    INNER JOIN detalle_asistencia det_a
                                                    ON A.id_asistencia = det_a.id_asistencia
                                                    INNER JOIN estado_asistencia E
                                                    ON A.id_estado = E.id_estado
                                                    INNER JOIN clase C
                                                    ON det_a.id_clase = C.id_clase
                                                    INNER JOIN persona pe
                                                    ON det_a.rut_alumno = pe.rut
                                                    INNER JOIN alumno alu
                                                    ON det_a.rut_alumno = alu.rut_alumno
                                                    INNER JOIN curso cur
                                                    ON cur.id_curso = alu.id_curso
                                                    INNER JOIN asignatura asig
                                                    ON C.id_asignatura = asig.id_asignatura
                                                    ORDER BY asig.descripcion ASC, C.fecha ASC, "nombre_completo" ASC;
            valida := 1;
        END IF;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_listar_asistencia;

    PROCEDURE SP_LISTAR_ASISTENCIA_CLASE(p_claseid clase.id_clase%type, p_cursoid clase.id_curso%type, lista OUT SYS_REFCURSOR, valida OUT NUMBER) is
        v_cantidad NUMBER DEFAULT 0;
    BEGIN
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM detalle_asistencia;
        IF v_cantidad > 0 THEN 
            OPEN lista FOR 
                    SELECT alu.rut_alumno, pe.nombre  ||' ' ||pe.nombre_s ||' '|| pe.nombre_t ||' '|| pe.apellido_p ||' '|| pe.apellido_m AS "nombre_completo",
                    a.fecha,a.hora, e.descripcion ,codigo_qr
                        FROM ALUMNO alu
                            INNER JOIN PERSONA pe
                            ON alu.rut_alumno = pe.rut
                            INNER JOIN DETALLE_ASISTENCIA det_a
                            ON alu.rut_alumno = det_a.rut_alumno
                            INNER join clase c
                            on det_a.id_clase = c.id_clase
                            INNER JOIN ASISTENCIA a
                            ON det_a.id_asistencia = a.id_asistencia
                            INNER JOIN ESTADO_ASISTENCIA e
                            ON a.id_estado = e.id_estado
                            where c.id_clase = p_claseid AND c.id_curso = p_cursoid
                            ORDER BY alu.rut_alumno asc, "nombre_completo" asc, e.descripcion desc;
                    
            valida := 1;
        END IF;
   EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END SP_LISTAR_ASISTENCIA_CLASE;
    
    PROCEDURE SP_GUARDAR_ASISTENCIA (p_claseid clase.id_clase%type, p_cursoid clase.id_curso%type, p_valida OUT NUMBER) IS
        v_id number;
        v_valida number;
        CURSOR cur_asistencia IS
            select alu.rut_alumno
            from alumno alu
                INNER JOIN PERSONA pe
                ON alu.rut_alumno = pe.rut
                INNER JOIN CURSO cur
                ON alu.id_curso = cur.id_curso
                INNER JOIN clase c
                ON cur.id_curso = c.id_curso
                WHERE c.id_clase = p_claseid and c.id_curso = p_cursoid;
    BEGIN 
            FOR x IN cur_asistencia
            LOOP
                BEGIN 
                    SELECT id_asistencia INTO v_id
                    FROM DETALLE_ASISTENCIA 
                    WHERE rut_alumno = x.rut_alumno;
                EXCEPTION
                    when OTHERS THEN 
                        -- SI CAE EN EXCEPTION NO ESCANEÓ EL CÓDIGO QR
                        -- INGRESAMOS AL ALUMNO COMO AUSENTE Y DEJAMOS UN REPORTE EN LA TABLA ERRORES
                        PKG_ASISTENCIA.sp_insertar_asistencia(2, p_claseid, x.rut_alumno,v_valida);
                        pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
                        pkg_errores.reg_errores.codigo_error := SQLCODE;
                        pkg_errores.reg_errores.mensaje_error := 'El alumno del curso'||p_cursoid||' con el rut '||x.rut_alumno|| ' NO ESCANEÓ EL CÓDIDO QR DE LA CLASE ' || p_claseid;
                        pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_GUARDAR_ASISTENCIA';
                        pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
                        pkg_errores.reg_errores.hora := pkg_errores.v_hora;
                        pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
                END;
            END LOOP;
    END SP_GUARDAR_ASISTENCIA;
    
    PROCEDURE sp_buscar_asistencia2(p_rutalumno IN alumno.rut_alumno%type, p_claseid IN CLASE.id_clase%type ,valida OUT NUMBER) IS
        v_cantidad NUMBER DEFAULT 0;
    BEGIN 
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM detalle_asistencia WHERE rut_alumno = p_rutalumno and id_clase = p_claseid;
            IF v_cantidad > 0 THEN 
                        SELECT  e.id_estado INTO valida
                            FROM asistencia A
                                INNER JOIN detalle_asistencia det_a
                                ON A.id_asistencia = det_a.id_asistencia
                                INNER JOIN estado_asistencia E
                                ON A.id_estado = E.id_estado
                                INNER JOIN clase C
                                ON det_a.id_clase = C.id_clase
                                INNER JOIN persona pe
                                ON det_a.rut_alumno = pe.rut
                                INNER JOIN alumno alu
                                ON det_a.rut_alumno = alu.rut_alumno
                                INNER JOIN curso cur
                                ON cur.id_curso = alu.id_curso
                                INNER JOIN asignatura asig
                                ON C.id_asignatura = asig.id_asignatura
                                WHERE alu.rut_alumno = p_rutalumno and c.id_clase = p_claseid;
                END IF;
            EXCEPTION
                WHEN OTHERS THEN 
                    valida := 2;
    END sp_buscar_asistencia2;
    
    PROCEDURE SP_LISTAR_ASISTENCIA_ASIGNATURA(p_rutalumno IN alumno.rut_alumno%type, lista OUT SYS_REFCURSOR) is
    BEGIN 
            OPEN lista FOR SELECT * FROM RESUMEN_ASISTENCIA WHERE rut_alumno = p_rutalumno;
    exception
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA_CLASE';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END SP_LISTAR_ASISTENCIA_ASIGNATURA;
    
END pkg_asistencia;


----------------------------------------------------
-- PACKAGE BOBY ALUMNO
----------------------------------------------------

CREATE OR REPLACE PACKAGE BODY pkg_alumno IS
    
    PROCEDURE sp_listar_alumno(lista OUT SYS_REFCURSOR, valida OUT NUMBER) IS
    v_cantidad NUMBER DEFAULT 0;
    BEGIN
        valida := 0;
        SELECT COUNT(*) INTO v_cantidad FROM alumno;
        IF v_cantidad > 0 THEN 
        OPEN lista FOR SELECT * FROM persona P
                                INNER JOIN alumno A
                                ON P.rut = A.rut_alumno;
        valida := 1;
        END IF;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_ASISTENCIA.SP_LISTAR_ASISTENCIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_listar_alumno;
    
END pkg_alumno;

-------------------------------------------------
-- PACKAGE BODY USUARIO
-------------------------------------------------
CREATE OR REPLACE PACKAGE BODY pkg_usuario IS
    PROCEDURE sp_login(p_usuario IN usuario.nombre_usuario%TYPE, p_contrasenia IN usuario.contrasenia%TYPE, p_tipo_usuario OUT NUMBER, p_nombre OUT persona.nombre%TYPE) IS
    BEGIN 
        p_tipo_usuario := 0;
        p_nombre := '';
        SELECT P.nombre, u.id_tipo INTO p_nombre, p_tipo_usuario
        FROM usuario u
        INNER JOIN persona P
        ON u.nombre_usuario = P.nombre_usuario
        WHERE u.nombre_usuario = p_usuario AND 
        u.contrasenia = p_contrasenia 
        AND u.id_estado = 1;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_LOGIN';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_login;
    
    PROCEDURE sp_cambiar_contrasenia(p_correo IN  persona.email%TYPE, p_nueva_pass IN usuario.contrasenia%TYPE, p_valida OUT NUMBER ) IS
        v_registro persona.rut%TYPE;
    BEGIN 
        p_valida := 0;
        SELECT nombre_usuario INTO v_registro
        FROM persona WHERE email = p_correo;
        UPDATE usuario SET contrasenia = p_nueva_pass WHERE nombre_usuario = v_registro;
        IF SQL%rowcount > 0 THEN
            p_valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_USUARIO.SP_CAMBIAR_CONTRASENIA';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
    END sp_cambiar_contrasenia;
    
END pkg_usuario;

-------------------------------------------------
-- PACKAGE BODY CODIGO QR
-------------------------------------------------

CREATE OR REPLACE PACKAGE BODY pkg_codigo_qr IS
    PROCEDURE sp_generar_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER) IS
    BEGIN 
        p_valida := 0;
        UPDATE clase SET codigo_qr = p_qr WHERE id_clase = claseid;
        IF SQL%rowcount > 0 THEN
            p_valida := 1;
        END IF;
        COMMIT;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.PKG_CODIGO_QR';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);

    END sp_generar_codigo;
    
    PROCEDURE sp_escanear_codigo(claseid IN clase.id_clase%TYPE, p_qr IN clase.codigo_qr%TYPE, p_valida OUT NUMBER) IS
        v_codigo clase.codigo_qr%TYPE;
    BEGIN 
            p_valida := 0;
            SELECT codigo_qr INTO v_codigo
            FROM clase WHERE id_clase = claseid;
        IF v_codigo = p_qr THEN 
            p_valida := 1;
        END IF;
    EXCEPTION
        WHEN too_many_rows THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se retornan más filas de las requeridas.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN invalid_number THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una conversión númerica que no coincide con el tipo de dato definido.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN no_data_found THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'No se encuentran datos.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN zero_divide THEN
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := 'Se intentó hacer una división por 0.';
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);
        WHEN OTHERS THEN 
            pkg_errores.reg_errores.ID := seq_errores.NEXTVAL;
            pkg_errores.reg_errores.codigo_error := SQLCODE;
            pkg_errores.reg_errores.mensaje_error := sqlerrm;
            pkg_errores.reg_errores.subprograma := 'PKG_CODIGO_QR.SP_ESCANEAR_CODIGO';
            pkg_errores.reg_errores.fecha := pkg_errores.v_fecha;
            pkg_errores.reg_errores.hora := pkg_errores.v_hora;
            pkg_errores.sp_errores (pkg_errores.reg_errores.ID , pkg_errores.reg_errores.codigo_error, pkg_errores.reg_errores.mensaje_error, pkg_errores.reg_errores.subprograma, pkg_errores.reg_errores.fecha, pkg_errores.reg_errores.hora);

    END sp_escanear_codigo;
    
END pkg_codigo_qr;


------------------------------------------------------------------
-- CREAR JOB QUE EJECUTE UN RESUMEN
-- DE LAS ASISTENCIAS TODOS LOS DÍAS A LAS 3AM
------------------------------------------------------------------

BEGIN
    dbms_scheduler.create_job (
       job_name          =>  'JOB_RESUMEN_ASISTENCIA_DIARIA', -- Nombre del JOB 
       job_type            =>  'STORED_PROCEDURE', --  Que ejecuará en este caso un SP
       job_action          =>  'SP_RESUMEN_ASISTENCIA', -- Nombre del SP
       start_date          =>  NULL, -- Fecha de Inicio de la ejecución 
       repeat_interval  => 'FREQ=DAILY; BYHOUR=03', -- Frecuencia de ejecución 3AM
       enabled             =>  TRUE); -- Dejamos el JOB activo
END;


------------------------------------------------------------------

-- Verificamos los JOBS creados
SELECT * FROM all_scheduler_jobs;

-- Revisar el log de los JOBS
SELECT * FROM all_scheduler_job_run_details;

COMMIT;


------------------------------------------------------------------
--- EJECUTAR JOB
------------------------------------------------------------------

EXEC dbms_scheduler.run_job('JOB_RESUMEN_ASISTENCIA_DIARIA');



------------------------------------------------------------------




------------------------------------------------------------------

-- Borrar un JOB 

------------------------------------------------------------------

BEGIN
  dbms_scheduler.drop_job(job_name => 'JOB_RESUMEN_ASISTENCIA_DIARIA'); 
END;




-------------------------------------
-- ZONA  DE TESTS 
-------------------------------------


SET SERVEROUTPUT ON;
---- Probar LISTAR Y BUSCAR
VAR cursor_x refcursor
VAR v_valida NUMBER
EXEC pkg_asistencia.SP_LISTAR_ASISTENCIA_ASIGNATURA('19708456',:cursor_x);
PRINT cursor_x;
PRINT v_valida;


DECLARE
    v_tipo NUMBER;
    v_nombre VARCHAR2(200);
BEGIN 
    --pkg_asistencia.sp_insertar_asistencia(1, 2,'20281676',v_tipo);
    --pkg_asistencia.SP_GUARDAR_ASISTENCIA(2, 10,v_tipo);
    --pkg_asistencia.sp_modificar_asistencia(4,1,v_tipo);
    pkg_asistencia.sp_buscar_asistencia2('19708456',2,v_tipo);
    dbms_output.put_line('Valida es ' || v_tipo );
END;



-- LISTAR CURSOS POR PROFESOR
SELECT c.descripcion
FROM CURSO c
INNER JOIN DETALLE_CURSO det
ON det.id_curso = c.id_curso
where det.rut_profesor = 17268410;

-- listar ASIGNATURAS POR  profe y curso
SELECT * FROM ASIGNATURA a
INNER JOIN DETALLE_ASIGNATURA det_a
ON a.id_asignatura = det_a.id_asignatura
INNER JOIN clase c
ON det_a.id_asignatura = c.id_asignatura
where det_a.rut_profesor = 12647021 and c.id_curso = 10;

-- LISTAR CLASES POR PROFE al elegir un curso, luego la asignatura 
SELECT * FROM CLASE 
WHERE rut_profesor = 12647021 and id_curso = 10 and id_asignatura = 1;

-- LISTAR ASIGNATURAS POR ALUMNO SEGÚN SU CURSO
SELECT DISTINCT(asig.descripcion)
FROM ALUMNO a
INNER JOIN CURSO c
ON a.id_curso = c.id_curso
INNER JOIN CLASE cla
ON cla.id_curso = c.id_curso
INNER JOIN asignatura asig
ON cla.id_asignatura = asig.id_asignatura
where a.rut_alumno = '19317764';


-- LISTAR CLASES POR ALUMNO SEGÚN CURSO y asignatura seleccionada

SELECT *
FROM ALUMNO a
INNER JOIN CURSO c
ON a.id_curso = c.id_curso
INNER JOIN CLASE cla
ON cla.id_curso = c.id_curso
where a.rut_alumno = '19317764' and cla.id_asignatura=1;


